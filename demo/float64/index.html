<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../styles.css" />
    <title>blue-noise.js Demo</title>
  </head>
  <body
    style="
      gap: 8px;
      background-color: black;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    ">
    <h1>blue-noise.js Demo</h1>
    <h2>By 901D3</h2>
    <h3>Float64</h3>
    <canvas
      id="blueNoiseCanvas"
      style="border: 3px solid #ff0; image-rendering: pixelated"></canvas>
    <div
      class="settings_container"
      style="background-color: #a4947b; border: 2px solid #ff9d00; padding: 3px; width: 500px">
      <div class="settings_label-select">
        <span>Method</span>
        <select id="blueNoiseAlgo">
          <option value="extendedVACluster">Extended Void and Cluster</option>
          <option value="georgievFajardo">Georgiev-Fajardo(Simulated annealing)</option>
          <option value="candidateMethodVACluster">Candidate Method(Void and Cluster)</option>
          <option value="bestCandidate">Best Candidate(Mitchell's)</option>
          <option value="relaxation">Relaxation(Lloyd's)</option>
          <option value="gaussianBlueNoise">Gaussian Blue Noise</option>
        </select>
      </div>
      <textarea id="blueNoiseCustomKernel" placeholder="Convolve kernel. 2D array"></textarea>
      <textarea id="blueNoiseMatrixOutput" placeholder="Output array"></textarea>
      <button onclick="showResult()">Show result as matrix</button>
      <div class="whitehr"></div>
      <div class="settings_label-input">
        <span>Width</span>
        <input type="number" id="blueNoiseWidth" value="64" />
      </div>
      <div class="settings_label-input">
        <span>Height</span>
        <input type="number" id="blueNoiseHeight" value="64" />
      </div>
      <div class="settings_label-input">
        <span>Sigma radius multiplier</span>
        <input type="number" id="blueNoiseGaussianSigmaRadiusMultiplier" value="10" />
      </div>
      <div class="settings_label-input">
        <span>Sigma(Image)</span>
        <input type="number" id="blueNoiseSigmaImage" value="1.9" />
      </div>
      <div class="settings_label-input">
        <span>Sigma sample(candidate method)</span>
        <input type="number" id="blueNoiseSigmaSample" value="1" />
      </div>
      <div class="settings_label-input">
        <span>Samples</span>
        <input type="number" id="blueNoiseSamples" value="100" />
      </div>
      <div class="settings_label-input">
        <span>Iterations</span>
        <input type="number" id="blueNoiseIterations" value="15" />
      </div>
      <div class="settings_label-input">
        <span>MBC Candidates</span>
        <input type="number" id="blueNoiseMBCCandidates" value="20" />
      </div>
      <div class="settings_label-input">
        <span>P Norm</span>
        <input type="number" id="blueNoisePNorm" value="0.5" />
      </div>
      <div class="settings_checkbox-label-input">
        <input type="checkbox" id="blueNoiseUseAdaptiveSigma" />
        <span>Use adaptive sigma(uneven dots fix)</span>
        <input type="number" id="blueNoiseInitialSigmaScale" value="0.5" />
      </div>
      <button onclick="blueNoiseWrapper()">Generate</button>
      <button onclick="downloadRaw()">Download raw</button>
      <span id="generateTime"></span>
    </div>
  </body>
  <script src="../../src/blue-noise-utils.js"></script>
  <script src="../../src/blue-noise-float64.js"></script>
  <script>
    var blueNoiseCanvas = document.getElementById("blueNoiseCanvas");
    var blueNoiseCtx = blueNoiseCanvas.getContext("2d");
    let result;

    function findHighest(matrix) {
      let value = -Infinity;

      for (let i = matrix.length - 1; i >= 0; i--) {
        const v = matrix[i];
        if (v > value) value = v;
      }

      return value;
    }

    function findLowest(matrix) {
      let value = Infinity;

      for (let i = matrix.length - 1; i >= 0; i--) {
        const v = matrix[i];
        if (v < value) value = v;
      }

      return value;
    }

    function blueNoiseWrapper() {
      const blueNoiseWidth = Number(document.getElementById("blueNoiseWidth").value);
      const blueNoiseHeight = Number(document.getElementById("blueNoiseHeight").value);
      const blueNoiseAlgo = document.getElementById("blueNoiseAlgo").value;
      blueNoiseCanvas.width = blueNoiseWidth;
      blueNoiseCanvas.height = blueNoiseHeight;

      const sqSz = blueNoiseWidth * blueNoiseHeight;

      const samples = Number(document.getElementById("blueNoiseSamples").value);
      const sigmaImage = Number(document.getElementById("blueNoiseSigmaImage").value);
      const sigmaSample = Number(document.getElementById("blueNoiseSigmaSample").value);
      const iterations = Number(document.getElementById("blueNoiseIterations").value);
      const pNorm = Number(document.getElementById("blueNoisePNorm").value);

      const MBCCandidates = Number(document.getElementById("blueNoiseMBCCandidates").value);

      const t0 = performance.now();

      BlueNoiseFloat64.gaussianSigmaRadiusMultiplier = Number(
        document.getElementById("blueNoiseGaussianSigmaRadiusMultiplier").value
      );

      BlueNoiseFloat64.useAdaptiveSigmaCandidateAlgo = document.getElementById(
        "blueNoiseUseAdaptiveSigma"
      ).checked;

      BlueNoiseFloat64.initialSigmaScale = Number(
        document.getElementById("blueNoiseInitialSigmaScale").value
      );

      if (blueNoiseAlgo === "extendedVACluster") {
        let kernel = null;

        if (document.getElementById("blueNoiseCustomKernel").value) {
          kernel = JSON.parse(document.getElementById("blueNoiseCustomKernel").value);
        }

        result = BlueNoiseFloat64.extendedVoidAndClusterWrapAround(
          blueNoiseWidth,
          blueNoiseHeight,
          sigmaImage,
          sigmaSample,
          samples,
          kernel
        );
      } else if (blueNoiseAlgo === "georgievFajardo") {
        let kernel = null;

        if (document.getElementById("blueNoiseCustomKernel").value) {
          kernel = JSON.parse(document.getElementById("blueNoiseCustomKernel").value);
        }

        result = new Float64Array(sqSz);
        for (let i = 0; i < sqSz; i++) result[i] = i;
        //BlueNoiseUtils.shuffle(result);

        BlueNoiseFloat64.georgievFajardoWrapAroundInPlace(
          result,
          blueNoiseWidth,
          blueNoiseHeight,
          sigmaImage,
          sigmaSample,
          iterations,
          pNorm,
          kernel
        );
      } else if (blueNoiseAlgo === "candidateMethodVACluster") {
        let kernel = null;

        if (document.getElementById("blueNoiseCustomKernel").value) {
          kernel = JSON.parse(document.getElementById("blueNoiseCustomKernel").value);
        }

        if (samples > 0 && samples < sqSz) {
          result = new Uint32Array(sqSz);
          for (let i = 0; i < samples; i++) result[i] = 1;
          BlueNoiseUtils.shuffle(result);

          if (BlueNoiseFloat64.useAdaptiveSigmaCandidateAlgo) {
            BlueNoiseFloat64.adaptiveCandidateMethodWrapAroundInPlace(
              result,
              blueNoiseWidth,
              blueNoiseHeight,
              BlueNoiseFloat64.gaussianSigmaRadiusMultiplier
            );
          } else {
            BlueNoiseFloat64.candidateMethodWrapAroundInPlace(
              result,
              blueNoiseWidth,
              blueNoiseHeight,
              sigmaSample,
              kernel
            );
          }
        } else if (samples === sqSz) result.fill(1);
      } else if (blueNoiseAlgo === "bestCandidate") {
        const idxResult = BlueNoiseFloat64.mitchellBestCandidateWrapAround(
          blueNoiseWidth,
          blueNoiseHeight,
          samples,
          MBCCandidates
        );

        result = new Uint32Array(sqSz);

        for (let i = 0; i < samples; i++) result[idxResult[i] | 0] = 1;
      } else if (blueNoiseAlgo === "relaxation") {
        const idxXArray = new Float64Array(samples);
        const idxYArray = new Float64Array(samples);

        for (let i = 0; i < samples; i++) {
          idxXArray[i] = Math.random() * blueNoiseWidth;
          idxYArray[i] = Math.random() * blueNoiseHeight;
        }

        for (let i = 0; i < iterations; i++) {
          BlueNoiseFloat64.lloydRelaxationWrapAroundInPlace(
            idxXArray,
            idxYArray,
            blueNoiseWidth,
            blueNoiseHeight
          );
        }

        result = new Uint8Array(sqSz);

        for (let i = 0; i < samples; i++) {
          result[(idxYArray[i] | 0) * blueNoiseWidth + (idxXArray[i] | 0)] = 1;
        }
      } else if (blueNoiseAlgo === "gaussianBlueNoise") {
        const idxXArray = new Float64Array(samples);
        const idxYArray = new Float64Array(samples);

        for (let i = 0; i < samples; i++) {
          idxXArray[i] = Math.random() * blueNoiseWidth;
          idxYArray[i] = Math.random() * blueNoiseHeight;
        }

        for (let i = 0; i < iterations; i++) {
          BlueNoiseFloat64.gaussianBlueNoiseWrapAroundInPlace(
            idxXArray,
            idxYArray,
            blueNoiseWidth,
            blueNoiseHeight,
            sigmaImage
          );
        }

        result = new Uint8Array(sqSz);

        for (let i = 0; i < samples; i++) {
          result[(idxYArray[i] | 0) * blueNoiseWidth + (idxXArray[i] | 0)] = 1;
        }
      }

      generateTime.innerHTML = "Generating took " + (performance.now() - t0) + "ms";

      const frame = blueNoiseCtx.getImageData(0, 0, blueNoiseWidth, blueNoiseHeight);
      const imageData = frame.data;
      const denom = (1 / findHighest(result)) * 255;
      const lowest = findLowest(result);

      for (let i = 0; i < sqSz; i++) imageData[i * 4 + 3] = 255;

      for (let y = 0; y < blueNoiseHeight; y++) {
        const yOffs = y * blueNoiseWidth;

        for (let x = 0; x < blueNoiseWidth; x++) {
          let i = yOffs + x;

          const v = ((result[i] - lowest) * denom + 0.5) | 0;

          i <<= 2;
          imageData[i] = v;
          imageData[i + 1] = v;
          imageData[i + 2] = v;
        }
      }

      blueNoiseCtx.putImageData(frame, 0, 0);
    }

    function downloadRaw() {
      const blob = new Blob([result.buffer], {type: "application/octet-stream"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "blue_noise.raw";
      a.click();
      URL.revokeObjectURL(url);
    }

    function showResult() {
      const blueNoiseWidth = Number(document.getElementById("blueNoiseWidth").value);
      const blueNoiseHeight = Number(document.getElementById("blueNoiseHeight").value);

      const matrixResult = [];

      for (let y = 0; y < blueNoiseHeight; y++) {
        if (!matrixResult[y]) matrixResult[y] = [];

        const yOffs = y * blueNoiseWidth;

        for (let x = 0; x < blueNoiseWidth; x++) {
          matrixResult[y][x] = result[yOffs + x];
        }
      }

      document.getElementById("blueNoiseMatrixOutput").value = JSON.stringify(matrixResult);
    }
  </script>
</html>
